package com.soulguard.modules.exploit;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandSendEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.event.server.TabCompleteEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import com.soulguard.SoulGuard;
import com.soulguard.api.SecurityModule;

public class PacketInspector implements SecurityModule, Listener {

    private final SoulGuard plugin;
    private boolean enabled;
    private final Map<UUID, Long> lastTabComplete = new ConcurrentHashMap<>();

    public PacketInspector(SoulGuard plugin) {
        this.plugin = plugin;
    }

    @Override
    public String getName() {
        return "PacketInspector";
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public void enable() {
        this.enabled = true;
        plugin.getLogManager().logInfo("PacketInspector enabled (Anti-Crash protection active).");
    }

    @Override
    public void disable() {
        this.enabled = false;
    }

    @Override
    public void reload() {
    }

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        lastTabComplete.remove(event.getPlayer().getUniqueId());
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    public void onCommandSend(PlayerCommandSendEvent event) {
        if (!enabled)
            return;

        Player player = event.getPlayer();
        if (player.hasPermission("soulguard.admin"))
            return;

        // Strict Command Hiding: 10/10 Privacy Protection
        java.util.List<String> whitelist = plugin.getConfig().getStringList("modules.PacketInspector.whitelist");
        if (whitelist.isEmpty()) {
            // Default safe commands if no whitelist is provided
            whitelist = java.util.Arrays.asList("help", "sg", "soulguard", "l", "login", "reg", "register", "pin",
                    "2fa", "report", "me", "msg", "w", "tell");
        }

        final java.util.List<String> finalWhitelist = whitelist;

        event.getCommands().removeIf(cmd -> {
            // Hide specific sensitive plugin syntaxes
            if (cmd.contains(":"))
                return true;

            // Only allow whitelisted commands
            return !finalWhitelist.contains(cmd.toLowerCase());
        });
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onTabComplete(TabCompleteEvent event) {
        if (!enabled)
            return;

        if (!(event.getSender() instanceof Player))
            return;
        Player player = (Player) event.getSender();

        // Rate limit tab completion to prevent crashing/spamming
        UUID uuid = player.getUniqueId();
        long now = System.currentTimeMillis();
        if (lastTabComplete.containsKey(uuid) && now - lastTabComplete.get(uuid) < 200) {
            event.setCancelled(true);
            return;
        }
        lastTabComplete.put(uuid, now);

        // Hide sensitive completions
        String buffer = event.getBuffer();
        if (buffer.startsWith("/") && buffer.contains(":")) {
            event.setCancelled(true);
        }
    }

    /* 
     * NOTE: To fully protect against NBT Overload, we would typically use ProtocolLib 
     * or deep NMS hooks. Since we are in a high-security context, we will add 
     * a generic check for internal Bukkit inventory events that might carry NBT.
     */
    @EventHandler(priority = EventPriority.LOWEST)
    public void onInventoryPacket(org.bukkit.event.inventory.InventoryClickEvent event) {
        if (!enabled) return;
        
        ItemStack item = event.getCurrentItem();
        if (item != null && item.hasItemMeta()) {
            ItemMeta meta = item.getItemMeta();
            // Estimating NBT size via string length of meta (Safe fallback for Bukkit API)
            if (meta != null && meta.toString().length() > 5000) {
                event.setCancelled(true);
                if (event.getWhoClicked() instanceof Player) {
                    Player p = (Player) event.getWhoClicked();
                    p.sendMessage(com.soulguard.util.ColorUtil.translate("&c&l[Security] &7Item rejected: Malicious NBT detected."));
                    plugin.getLogManager().logWarn("Malicious NBT detected from " + p.getName() + " (Meta size: " + meta.toString().length() + ")");
                }
            }
        }
    }
}
