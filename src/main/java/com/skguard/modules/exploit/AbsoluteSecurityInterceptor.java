package com.skguard.modules.exploit;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerMoveEvent;

import com.skguard.SKGuard;
import com.skguard.api.SecurityModule;
import com.skguard.logger.AuditManager;
import com.skguard.logger.BypassTracker;
import com.skguard.util.ColorUtil;

public class AbsoluteSecurityInterceptor implements SecurityModule, Listener {

    private final SKGuard plugin;
    private boolean enabled;

    public AbsoluteSecurityInterceptor(SKGuard plugin) {
        this.plugin = plugin;
    }

    @Override
    public String getName() {
        return "AbsoluteSecurityInterceptor";
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public void enable() {
        this.enabled = true;
        Bukkit.getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        this.enabled = false;
    }

    @Override
    public void reload() {}

    // --- ENFORCEMENT (LOWEST) ---
    // We cancel events here before almost any other plugin can handle them.

    @EventHandler(priority = EventPriority.LOWEST, ignoreCancelled = false)
    public void onMoveLowest(PlayerMoveEvent event) {
        if (!enabled) return;
        if (isRestricted(event.getPlayer())) {
            event.setCancelled(true);
        }
    }

    @EventHandler(priority = EventPriority.LOWEST, ignoreCancelled = false)
    public void onInteractLowest(PlayerInteractEvent event) {
        if (!enabled) return;
        if (isRestricted(event.getPlayer())) {
            event.setCancelled(true);
        }
    }

    @EventHandler(priority = EventPriority.LOWEST, ignoreCancelled = false)
    public void onCommandLowest(PlayerCommandPreprocessEvent event) {
        if (!enabled) return;
        String rawMsg = event.getMessage();
        String cmd = rawMsg.toLowerCase().trim();
        
        // --- Deep Sanitization (SEC-COM-001) ---
        // Prevent bypassing via spaces, colons (minecraft:tell) or other common vectors
        if (cmd.startsWith("/") && cmd.contains(":")) {
            String[] parts = cmd.split(" ");
            if (parts[0].contains(":")) {
                event.setCancelled(true);
                event.getPlayer().sendMessage(ColorUtil.translate("&c&l[Security] &7Namespaced commands are blocked for your protection. &8(SEC-COM-001)"));
                return;
            }
        }

        // Allow ONLY auth commands for restricted players
        if (isRestricted(event.getPlayer())) {
            boolean allowed = false;
            java.util.List<String> whitelistRegex = plugin.getConfig().getStringList("general.allowed-commands-regex");
            if (whitelistRegex.isEmpty()) {
                // Fallback to hardcoded defaults if config is empty
                allowed = cmd.startsWith("/login") || cmd.startsWith("/register") || cmd.startsWith("/pin") || cmd.startsWith("/2fa");
            } else {
                for (String regex : whitelistRegex) {
                    if (rawMsg.matches(regex)) {
                        allowed = true;
                        break;
                    }
                }
            }

            if (!allowed) {
                event.setCancelled(true);
                event.getPlayer().sendMessage(ColorUtil.translate("&c&l[Security] &7Please authenticate before using this command. &8(SEC-COM-002)"));
            }
        }
    }

    // --- DETECTION (MONITOR) ---
    // We check if the event status was changed by another plugin (Bypass Attempt)

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = false)
    public void onMoveMonitor(PlayerMoveEvent event) {
        checkBypass(event.getPlayer(), event.isCancelled(), "Movement");
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = false)
    public void onInteractMonitor(PlayerInteractEvent event) {
        boolean cancelled = event.useInteractedBlock() == org.bukkit.event.Event.Result.DENY || event.useItemInHand() == org.bukkit.event.Event.Result.DENY;
        checkBypass(event.getPlayer(), cancelled, "Interaction");
    }

    private void checkBypass(Player player, boolean isCancelled, String action) {
        if (!enabled) return;
        if (isRestricted(player) && !isCancelled) {
            // Something "un-cancelled" the event!
            BypassTracker tracker = plugin.getModule(BypassTracker.class);
            if (tracker != null) {
                tracker.logBypass(player, "EventPriority-Bypass", 
                    "Another plugin tried to allow " + action + " for a restricted player.");
            }
            // Re-enforce cancellation immediately
            // Note: In MONITOR we can't change result normally, but we can log and alert.
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onCommandMonitor(PlayerCommandPreprocessEvent event) {
        if (!enabled) return;
        AuditManager audit = plugin.getModule(AuditManager.class);
        if (audit != null) {
            audit.trackCommand(event.getPlayer().getUniqueId(), event.getMessage());
        }
    }

    @EventHandler
    public void onQuit(org.bukkit.event.player.PlayerQuitEvent event) {
        AuditManager audit = plugin.getModule(AuditManager.class);
        if (audit != null) {
            audit.clearHistory(event.getPlayer().getUniqueId());
        }
    }

    private boolean isRestricted(Player player) {
        // Check if player is not authenticated or needs PIN
        return !plugin.getAuthModule().isAuthenticated(player.getUniqueId()) || (plugin.getStaffPIN() != null && plugin.getStaffPIN().isPending(player.getUniqueId()));
    }
}

