package com.skguard.modules.exploit;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import org.bukkit.Bukkit;
import org.bukkit.command.ConsoleCommandSender;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.PluginDescriptionFile;

import com.skguard.SKGuard;
import com.skguard.api.SecurityModule;
import com.skguard.util.ColorUtil;

public class PluginGuardModule implements SecurityModule {

    private final SKGuard plugin;
    private boolean enabled;
    private final List<String> scanReport = new ArrayList<>();

    public PluginGuardModule(SKGuard plugin) {
        this.plugin = plugin;
    }

    @Override
    public String getName() {
        return "PluginGuardModule";
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public void enable() {
        this.enabled = true;
        runFullAnalysis();
    }

    @Override
    public void disable() {
        this.enabled = false;
    }

    @Override
    public void reload() {
        runFullAnalysis();
    }

    public void runFullAnalysis() {
        scanReport.clear();
        scanReport.add("=== SKGuard Plugin Integrity & Conflict Report ===");
        scanReport.add("Date: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
        scanReport.add("");

        Plugin[] plugins = Bukkit.getPluginManager().getPlugins();
        scanReport.add("Analyzing " + plugins.length + " plugins...");
        scanReport.add("---------------------------------------------");

        for (Plugin p : plugins) {
            analyzePlugin(p);
        }

        detectConflicts(plugins);
        runReflectionCheck();

        saveAndReport();
    }

    private void runReflectionCheck() {
        scanReport.add("");
        scanReport.add("--- Reflection & Integrity Guard ---");
        
        // JDK SecurityManager is deprecated in Java 17+ and will be removed.
        scanReport.add("[Info] System SecurityManager check skipped (Deprecated in modern Java).");
        
        // Check for 'shady' classloaders or unexpected access patterns
        scanReport.add("[Info] Core fields are now volatile/protected to detect interference.");
    }

    private void analyzePlugin(Plugin p) {
        PluginDescriptionFile desc = p.getDescription();
        String name = p.getName();
        
        // 1. Metadata Checks
        if (desc.getVersion().isEmpty() || desc.getVersion().equals("1.0")) {
            addIssue("[Suspicious] " + name + " has default or missing version metadata.");
        }

        // 2. Permission Checks (Broad permissions)
        for (org.bukkit.permissions.Permission perm : desc.getPermissions()) {
            if (perm.getName().equals("*")) {
                addIssue("[Risk] " + name + " defines a wildcard '*' permission.");
            }
        }

        // 3. Known Malicious Patterns (Examples)
        String[] suspiciousKeywords = {"hack", "exploit", "backdoor", "opme", "forceop"};
        for (String key : suspiciousKeywords) {
            if (name.toLowerCase().contains(key)) {
                addIssue("[Danger] " + name + " contains suspicious keyword: " + key);
            }
        }
    }

    private void detectConflicts(Plugin[] plugins) {
        scanReport.add("");
        scanReport.add("--- Conflict Detection ---");
        
        List<String> names = java.util.Arrays.stream(plugins).map(Plugin::getName).collect(Collectors.toList());
        
        // Auth Conflicts
        String[] authPlugins = {"AuthMe", "xAuth", "LoginSecurity", "RoyalAuth", "UltraAuth"};
        for (String auth : authPlugins) {
            if (names.contains(auth)) {
                addIssue("[Conflict] Detected multiple Auth plugins: " + auth + ". This may cause verification bypasses.");
            }
        }

        // Security/Anti-Cheat Conflicts
        String[] securityPlugins = {"NoCheatPlus", "Matrix", "AAC", "Spartan", "GrimAC"};
        for (String sec : securityPlugins) {
            if (names.contains(sec)) {
                scanReport.add("[Info] " + sec + " is running alongside SKGuard. Ensure thresholds don't overlap.");
            }
        }
    }

    private void addIssue(String issue) {
        scanReport.add(issue);
    }

    private void saveAndReport() {
        ConsoleCommandSender console = Bukkit.getConsoleSender();
        console.sendMessage(ColorUtil.translate("&c&l[SKGuard] &fGenerando reporte de integridad de plugins..."));

        // Save to file
        File reportsDir = new File(plugin.getDataFolder(), "reports");
        if (!reportsDir.exists()) reportsDir.mkdirs();

        File reportFile = new File(reportsDir, "plugin-security-report.txt");
        try {
            Files.write(reportFile.toPath(), scanReport, StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            console.sendMessage(ColorUtil.translate("&a&l[SKGuard] &fReporte guardado en: &e" + reportFile.getPath()));
        } catch (IOException e) {
            plugin.getLogManager().logError("Could not save security report: " + e.getMessage());
        }

        // Log critical issues to console immediately
        for (String line : scanReport) {
            if (line.contains("[Danger]") || line.contains("[Conflict]") || line.contains("[Risk]")) {
                console.sendMessage(ColorUtil.translate("&e" + line));
            }
        }
    }
}

